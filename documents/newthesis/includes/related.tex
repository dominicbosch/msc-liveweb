\chapter{Related Work}

\section{Web Services / Web API's}
\index{Web Service}
\index{Web API}
% TODO dienste services WebAPI belegen mit referenzen wo begriff wie gebraucht wird
% Begriffe festnageln, definieren
Data and functionalities in the web were always accessible via web services, whatever this means.
reengineering of services in the beginning
with standardised REST API's we got to Web API, easy access and understandable


The fast evolving web has brought up a trend towards easy to master interfaces to services, the so called Web APIs.
They do not only provide access to mere services but whole applications that allow access over Web APIs.
These trending Web APIs benefit from a RESTful architecture which predominantly uses HTTP and thus relies on the most basic and powerful operations and the basis of the Web itself, the HTTP protocol. 

% TODO Enough on Web API's?

% quick (handling/mastering) accessible services and even whole web applications through so called Web APIs.
% Web APIs provide powerful tools to govern data and functionality in the web independently of any user interface from the service provider.
% The relatively
% Allowing access to these services via API is increasingly popular and allows to mash up these services

% Practically all services flood the user with events
% The web should be event driven, that's why we need an engine that deals with events and makes the web reactive
% There's still the challenge of filtering
% What's important to whom
% Plus the user needs to have tools to combine and add programmability to the combination,( such as conditions, selection of provided arguments and so on)

% % TODO Event Trigger
% \index{Event}
% \index{Event Trigger}

% % TODO Actions
% \index{Actions}

% % TODO engine
% \index{Engine}

\section{Webhooks}

% % TODO Webhooks
% \index{Webhooks}

% TODO Categorize Related Work!

\section{Mashups}
\index{Mashups}
Mashups combine information and functionality of more than one web service in a single place.
The mashing up of such web services allows data to be enhanced with new informations, processing / refinement of the information, or even ways to interact with them, e.g. through Google Maps.
Simple functions from different sources can be combined into more powerful ones, which influence data and services in a way their founders eventually didn't even think of.
Web service mashups have been developped ever since services in the web started to exist and were accessible in a more or less convenient way.
We introduce Paul Rademacher as an example for how recent the invention of web service mashups are.
He's one of the first inventors of such a web service mashup.
In the same year after Google Maps came up in 2005, he invented a site\cite{wwwRademacherOne,wwwRademacherTwo} that displayed Craigslist houses on a Google Map.
With no Google Maps API at that time, he needed time and skills to reverse engineer Google Map's functionalities.


A large number of such "static" mashups were and are still developped.
They are static in the way that they aggregate a fixed (and mostly low) number, of either data or functionality resources, to provide an enhanced resource in a specialized domain.
Of course Mashups can be mashed up again, to provide even more sophisticated functionality and data.
Some latest example Mashups, taken from the ProgrammableWeb\cite{wwwProgrammableWeb} directory, are:

\begin{itemize}
  \item Wifi and Plugs\cite{wwwWifiAndPlugs}: MapBox, Google Docs and Import.io API's used to display where Wi-Fi and plugs are available in London.
  \item MapLight\cite{wwwMapLight}: GovTrack.us and OpenSecrets API's used to combine political results with financial contributions to show how capital contributions affect voting.
  \item Shared Count\cite{wwwSharedCount}: Facebook, LinkedIn, Pinterest and Twitter API's used to display informations about how well spread a URL is on social media sites.
\end{itemize}

In the past few years, research and development for platforms to allow users to flexibly mashup Web APIs got attention.
% Web API mashups
With IFTTT and Zapier, two platforms have evolved out of this process.
Users that register on those platforms are provided with a multitude of Web API functions that act as event triggers and such that are used to execute actions.
The user is then free to combine these event triggers and actions in the way it suits best, creating helpful Web API mashups on their own.

% Since this is a quite new field the why and how is hidden from the research.
% you need events
% you need rules / rule language





\section{Rule Languages \& Engines}
\index{Rule}
\index{Engine}
\index{Rule Language}

It turns out that Web API mashing up is not able to bring reactivity to the web.
They are merely aggregations of services that only provide data or functions but no write possibilities such as web applications provide.
% only limited functionalty
% limited parametrization
% often only read / new aggregation / no writes
% TODO find mashup that does writes in a system! (not existing right?)

Thus 

% TODO
% To allow user-defined Web API mashups, a rule language is required which is capable to express ECA Rules. 


% TODO
% ECA
% \index{ECA}

%TODO Table with categorization of Rule languages

Several different rule languages have been developped for different purposes over the last years and they vary grately in their purpose.
% terms of usability for ECA Rules together with Web API mashups.
A compilation of research on different emerging rule-based languages and technologies \cite{2009-Paschke_Boley-RCER.pdf} gives an oveview over such efforts.
We examined different existing rule languages with respect to a certain use case to identify its applicability for reactivity in the web. % TODO find other word as applicability
The use case is defined such that the rule needs to suffice the ECA paradigm:

\begin{itemize}
  \item Event: Receipt of an Email
  \item Condition: Check for a certain sender
  \item Action: Store it remotely via a Web API
\end{itemize}

We defined an email event which the rule languages need to be able to process.
The JSON representation of the given email event is shown in Listing~\ref{lstemail}.

\begin{Verbatim}[frame=single,fontsize=\footnotesize,commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1,xleftmargin
=.3in]
\PY{p}{\PYZob{}}
  \PY{n+nt}{\PYZdq{}eventname\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}email\PYZdq{}}\PY{p}{,}
  \PY{n+nt}{\PYZdq{}body\PYZdq{}}\PY{p}{:} \PY{p}{\PYZob{}}
    \PY{n+nt}{\PYZdq{}sender\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}sender@mail.com\PYZdq{}}\PY{p}{,}
    \PY{n+nt}{\PYZdq{}subject\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}Important subject!\PYZdq{}}\PY{p}{,}
    \PY{n+nt}{\PYZdq{}textbody\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}Hi User,\PYZbs{}n\PYZbs{}nThis is a lengthy mail body\PYZdq{}}
  \PY{p}{\PYZcb{}}
\PY{p}{\PYZcb{}}
\end{Verbatim}
\begin{lstlisting}[label=lstemail,caption=Example E-Mail event expressed in JSON]
\end{lstlisting}

\subsection{RDF \& XML}
\index{RDF}
\index{XML}
An early ECA Rule Language for XML repositories\cite{Papamarkos03event-condition-actionrule} was postulated in 2003 and was picked up by many researches afterwards. It was designed to react on insert and delete events within XML repositories and as an action change XML documents.

\begin{lstlisting}[frame=single,float=ht,label=lstrdf,language=RDF,caption=E-Mail Example rule expressed in RDF]
	ON INSERT document(’inbound_queue.xml’)/mails/mail
	IF $delta/sender[.=’sender@mail.com’]
	DO DELETE document(’inbound_queue.xml’)/mails/mail;
		LET $api = resource("www.webapi.com") IN
		INSERT ($api, newcontent,
			<content>New mail: {$delta/subject}</content>)
\end{lstlisting}


Now apart from implementing a rules engine, we would also need to add an XML document event manager which interpretes and pushes events into the XML file \emph{inbound\_queue.xml}. Then again this instance would interprete the ouptuts of the ECA engine, which would theoretically manifest in other XML documents, and produce meaningful actions on remote hosts. This wouldn't be an architecture which has its focus on the solution of our use case and, as a result, add complexity and create an unnecessary overhead.

\subsection{Notation 3}
\index{Notation 3}
To make the lengthy RDF definitions smaller and more readable, Notation 3\cite{wwwn3} was designed and announced in 2005. Through the implies operator(=\textgreater) an "event" can be connected to an "action", both expressed in RDF's subject, predicate, object notation, which makes the expression of ECA rules a complicated and not very intuitive task. A solution to our use case would look as follows:

\begin{lstlisting}[frame=single,float=ht,label=lstn3,language=N3,caption=E-Mail Example rule expressed in Notation 3]
	{ ?x :event "email". ?x :sender "sender@mail.com" }
		=> { :webapi :newcontent ?x }
\end{lstlisting}

This language is used to express relations between entities and thus not really suitable for our use case, since we would require another interpreter to infer the actions. But concepts and ideas of the work that was done in these consortias could eventually still find influence into our solution.

\subsection{XChange/Xcerpt}
\index{XChange}\index{Xcerpt}
The rule language XChange\cite{2005-Patranjan-TLE.pdf} was the outcome of the REWERSE (\cite{wwwRewerse}, Reasoning on the Web with Rules and Semantics) project, which was funded by the EU and Switzerland. Their work influenced a number of future research. The language was designed to add reactive behaviour to a "static" web which is represented through XML resources. Thus we have action logics to alter such resources through insertions and deletions. Since we aim to utilize web API's for our rule language we need a more generic approach which adds flexibility in term of the API provided. But the thorough research done with the language XChange holds valuable concepts, especially in terms of temporal evet composition. This could be a rule according to our use case:

\begin{lstlisting}[frame=single,float=ht,label=lstxchange1,language=XChange,caption=E-Mail Example rule expressed in XChange]
	TRANSACTION
		in {
			resource { "http://www.webapi.com"},
			newcontents {{
				insert newcontent { var Mail }
			}}
		}
	ON
		xchange:event {{
			xchange:sender { "http://mailserver.com" },
			var Mail -> email {{
				sender { "sender@mail.com" }
			}}
		}}
	END
\end{lstlisting}

But XChange is designed to access other resources in an action and thus provides powerful tools:

\begin{lstlisting}[frame=single,float=ht,label=lstxchange2,language=XChange,caption=XChange Rule accesses remote resource]
	TRANSACTION
		[...]
	ON
		[...]
	FROM
		in {
			resource { "http://www.weather.com"},
			temperatures {{
				var T -> temperature {{
					datetime { "2013-10-20-08:00:00AM" }
				}}
			}}
		}
	END
\end{lstlisting}

\subsection{JSON Rules}
\index{JSON Rules}
In 2008 \emph{JSON Rules}~\cite{2008-Giurca_Pascalau-JSON_Rules.pdf} was introduced as a language to easily react on specific DOM tree compositions.
The usage of JavaScript allowed them to provide simple functions which could be called directly by the actions, thus abstracting functionality from the language.
This key concept found influence into our language as it allows different layers of abstractions.
Through this it is possible to provide generic functions for expert user as well as very limited functions with only few possibilities for parameterization to be used by unexperienced persons.
A drawback of this language is its binding to DOM tree events, where we would want to react on any events happening in the world.
Also the temporal composition to complex events is not a subject of their work and needs further attention.


\begin{Verbatim}[frame=single,fontsize=\footnotesize,commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1,xleftmargin
=.3in]
\PY{p}{\PYZob{}}
    \PY{n+nt}{\PYZdq{}id\PYZdq{}}\PY{p}{:} \PY{l+m+mi}{0}\PY{p}{,}
    \PY{n+nt}{\PYZdq{}conditions\PYZdq{}}\PY{p}{:} \PY{p}{[}
        \PY{p}{\PYZob{}}
            \PY{n+nt}{\PYZdq{}type\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}email\PYZdq{}}\PY{p}{,}
            \PY{n+nt}{\PYZdq{}constraints\PYZdq{}}\PY{p}{:} \PY{p}{[}
                \PY{p}{\PYZob{}}
                    \PY{n+nt}{\PYZdq{}propertyName\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}sender\PYZdq{}}\PY{p}{,}
                    \PY{n+nt}{\PYZdq{}operator\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}EQ\PYZdq{}}\PY{p}{,}
                    \PY{n+nt}{\PYZdq{}restriction\PYZdq{}}\PY{p}{:} \PY{p}{\PYZob{}}
                        \PY{n+nt}{\PYZdq{}type\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}String\PYZdq{}}\PY{p}{,}
                        \PY{n+nt}{\PYZdq{}value\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}sender@mail.com\PYZdq{}}
                    \PY{p}{\PYZcb{}}
                \PY{p}{\PYZcb{}}\PY{p}{,}
                \PY{p}{\PYZob{}}
                    \PY{n+nt}{\PYZdq{}bind\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}\PYZdl{}S\PYZdq{}}\PY{p}{,}
                    \PY{n+nt}{\PYZdq{}propertyName\PYZdq{}}\PY{p}{:} \PY{l+s+s2}{\PYZdq{}subject\PYZdq{}}
                \PY{p}{\PYZcb{}}
            \PY{p}{]}
        \PY{p}{\PYZcb{}}
    \PY{p}{]}\PY{p}{,}
    \PY{n+nt}{\PYZdq{}actions\PYZdq{}}\PY{p}{:} \PY{p}{[}
        \PY{l+s+s2}{\PYZdq{}webapi(\PYZsq{}addcontent\PYZsq{}, \PYZdl{}S)\PYZdq{}}
    \PY{p}{]}
\PY{p}{\PYZcb{}}
\end{Verbatim}
\begin{lstlisting}[caption=E-Mail Example rule in JSON Rules]
\end{lstlisting}


\subsection{Kinetics Rule Language (KRL)}
\index{KRL}
A most recent (2011) open-source development is the Kinetic Rules Engine together with the Kinetics Rule Language~\cite{bookTheLiveWeb}.
It is built for the purpose of adding reactivity to the cloud.
The language is based on declarative syntax, enriched with imparative elements.
But it is a tedious task to get into a whole new language and their caveats.
\emph{authorization?}

\begin{lstlisting}[frame=single,float=h,label=lstkre,language=KRE,caption=E-Mail Example rule in KRL]
	rule store_mail {
		select when mail newmail
		sender re#sender@mail.com#
		subject re#*# setting(subj)
		http:post("http://www.webapi.com/newcontent")
		with params = {
			"text": subj
		}
	}
\end{lstlisting}


\subsection{(Reaction) RuleML}
\index{RuleML}
The basis of \emph{RuleML}~\cite{2006-Boley-RuleML.pdf} is datalog, a language in the intersection of SQL and Prolog.
In 2012 the \emph{Reaction RuleML}~\cite{2012-Paschke_etal-ReactionRuleML.pdf} language incorporated several different types of rules into the RuleML syntax, to establish a uniform syntax and interchangability of rules.
\emph{Reaction RuleML} is a valuable resource in terms of manifold research that has been done in the domain of rule languages, but the syntax is not user-friendly.


R2ML allows usage for RuleML together with many other dialects. Really!?

\begin{Verbatim}[frame=single,fontsize=\footnotesize,commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1,xleftmargin
=.3in]
  \PY{n+nt}{\PYZlt{}Rule} \PY{n+na}{style=}\PY{l+s}{\PYZdq{}active\PYZdq{}}\PY{n+nt}{\PYZgt{}}
    \PY{n+nt}{\PYZlt{}on}\PY{n+nt}{\PYZgt{}}
      \PY{n+nt}{\PYZlt{}Event}\PY{n+nt}{\PYZgt{}}
        \PY{n+nt}{\PYZlt{}Atom}\PY{n+nt}{\PYZgt{}}
          \PY{n+nt}{\PYZlt{}Rel} \PY{n+na}{per=}\PY{l+s}{\PYZdq{}value\PYZdq{}}\PY{n+nt}{\PYZgt{}}mail\PY{n+nt}{\PYZlt{}/Rel\PYZgt{}}
          \PY{n+nt}{\PYZlt{}Var}\PY{n+nt}{\PYZgt{}}sender\PY{n+nt}{\PYZlt{}/Var\PYZgt{}}
          \PY{n+nt}{\PYZlt{}Var}\PY{n+nt}{\PYZgt{}}subject\PY{n+nt}{\PYZlt{}/Var\PYZgt{}}
        \PY{n+nt}{\PYZlt{}/Atom\PYZgt{}}
      \PY{n+nt}{\PYZlt{}/Event\PYZgt{}}
    \PY{n+nt}{\PYZlt{}/on\PYZgt{}}
    \PY{n+nt}{\PYZlt{}if}\PY{n+nt}{\PYZgt{}}
      \PY{n+nt}{\PYZlt{}Atom}\PY{n+nt}{\PYZgt{}}
        \PY{n+nt}{\PYZlt{}op}\PY{n+nt}{\PYZgt{}}\PY{n+nt}{\PYZlt{}Rel}\PY{n+nt}{\PYZgt{}}equals\PY{n+nt}{\PYZlt{}/Rel\PYZgt{}}\PY{n+nt}{\PYZlt{}/op\PYZgt{}}
        \PY{n+nt}{\PYZlt{}Var}\PY{n+nt}{\PYZgt{}}sender\PY{n+nt}{\PYZlt{}/Var\PYZgt{}}
        \PY{n+nt}{\PYZlt{}Ind}\PY{n+nt}{\PYZgt{}}sender@mail.com\PY{n+nt}{\PYZlt{}/Ind\PYZgt{}}
      \PY{n+nt}{\PYZlt{}/Atom\PYZgt{}}
    \PY{n+nt}{\PYZlt{}/if\PYZgt{}}
    \PY{n+nt}{\PYZlt{}do}\PY{n+nt}{\PYZgt{}}
      \PY{n+nt}{\PYZlt{}Atom}\PY{n+nt}{\PYZgt{}}
        \PY{n+nt}{\PYZlt{}oid}\PY{n+nt}{\PYZgt{}}\PY{n+nt}{\PYZlt{}Ind} \PY{n+na}{uri=}\PY{l+s}{\PYZdq{}http://webapi.com\PYZdq{}}\PY{n+nt}{/\PYZgt{}}\PY{n+nt}{\PYZlt{}/oid\PYZgt{}}
        \PY{n+nt}{\PYZlt{}Rel}\PY{n+nt}{\PYZgt{}}newcontent\PY{n+nt}{\PYZlt{}/Rel\PYZgt{}}
        \PY{n+nt}{\PYZlt{}Var}\PY{n+nt}{\PYZgt{}}subject\PY{n+nt}{\PYZlt{}/Var\PYZgt{}} 
      \PY{n+nt}{\PYZlt{}/Atom\PYZgt{}}
    \PY{n+nt}{\PYZlt{}/do\PYZgt{}}
  \PY{n+nt}{\PYZlt{}/Rule\PYZgt{}}
\end{Verbatim}

% TODO RULE ENGINES!

%\section{Conclusion}
Most of the examined rule languages are designed for the interchangability of rules between different service providers. We do not attempt to jump into this domain but we rather pick up important concepts to manifest web API's as first class citizens of our rule language. This allows the ad-hoc design and implementation of reactive rules between existing web API's without the need for their cooperation in setting up their endpoint in a special way.

% TODO Rechtfertigung wieso nicht verwendet
% Java EE und KRL nicht anwendbar


% TODO performance artikel / paper ueber node.js