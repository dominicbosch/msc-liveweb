
\chapter{Conclusions \& Future Work}

The practical use case examples for our lightweighted prototype system showed the diversity of examples that can be run in it.
As soon as there are services that allow the access to an \textrm{\glspl{infosystem}}, we are able to orchestrate them, which is a promising insight.
But even though the Web gets ever more programmable it is still a tedious task for many \textrm{\glspl{webservice}} to get into communication.
Moreover it is a time consuming task to find the proper functionality in \textrm{\glspl{webapi}}, or certain functionality needs to be chained in order to get either to meaningful events or actions, or last but not least some functionality is just not accessible.
\textrm{\acrshort{rest}}ful \textrm{\glspl{webservice}} are a good example for lacking meaningful functionality, since they do not provide complex functionality but more or less read, write, update and delete logic for \textrm{\glspl{webresource}}.
For those reasons, we believe it was a good decision to encapsulate sometimes complex logic into the \textrm{Event Trigger} and \textrm{Action Dispatcher} modules.
Through this, also users that do not have a background in computer science are more likely able to forge their customzied reactive Web.


Many of the notional use case examples in chapter 4 have been implemented in the prototype system, but have brought important insight where it did not work instantly.
We found that it is difficult to detect changes on any arbitrary webpage in a useful way.
Our first attempt was to use a diff comparison utility, of which the result was hard to process because of the \textrm{\acrshort{html}} tags.
Another approach was to create an object tree from the \textrm{\acrshort{html}} document and calculate the difference between the last recorded object, which was more promising to detect changes all over a webpage.
The simplest approach was to use \textrm{Import.io} to define a part of a webpage to be observed and then detect changes only on this predefined part of the webpage over the \textrm{Import.io} \textrm{\gls{webapi}}.
We believe that there is a lot of value in detecting changes on static \textrm{\glspl{webresource}} in a proper way.
Future research could mold webpage change detection into some sort of an \textrm{Event Trigger} or even into a novel rule language that uses Web queries in the event part.
We were able to realize the enhancement of an existing \textrm{\gls{webapplication}} in large parts since proper \textrm{\glspl{webapi}} provide powerful tools to weild them.

An interesting insight was, that sometimes users whish for activity at a certain point in time instead of event-driven reactivity, which means that the reaction on time events seems to be desirable for users.
This could be handled in two ways through our model, either an \textrm{Event Trigger} is created which pushes an event at the exact point in time into the system, or an external \textrm{\gls{infosystem}} is pushing continuously primitive time events into our model over a \textrm{\gls{webhook}}.
The first option seems to be a bit of an overkill but means lesser event load for the model.
The latter option means a certain load depending on how small the event intervals are, but it reflects more the reality where we are used to time events in an interval of one second.
Through continous time events it is also easily possible for all users to setup rules for their desired point in time without having to select and parameterize an \textrm{Event Trigger} beforehand.

Our experiences with the prototype system show us that the conceptual model is suitable to impose real-time reactivity on existing \textrm{\glspl{infosystem}}.
We were successful in capturing events from \textrm{\glspl{infosystem}}, be it by actively pulling them over a service or passively getting it delivered over a \textrm{\gls{webhook}}.
A somewhat surprising finding was how few \textrm{\glspl{webapi}} support \textrm{\glspl{webhook}} for real-time notifications to  external \textrm{\glspl{infosystem}}.
We envision a future where the whole Web is event-driven and events are directed to any \textrm{\gls{infosystem}}, which is interested in them.
This would be the optimal case for effective real-time notifications and thus reactivity on the Web.
If the \textrm{\glspl{webapi}} remain passive without support for \textrm{\glspl{webhook}}, this will cause unnecessary computation and communication cost because of the polling that needs to be done.

A field which turned out to be beyond the scope of this thesis, but was intended to be part of the prototype as well, was the field of \textrm{\acrshort{cep}}.
Temporal composition of events should be taken care of in future research in this field since it allows to identify situations out of primitive events.
And it also allows to define semantically ever more complex situations out of existing ones.
With a growing number of events and their compositions, that are flowing through such a system, it would be useful to have an event relation describing framework on top of them, much like \textrm{\acrshort{rdf}} for \textrm{\glspl{webresource}}.
Also with a growing popularity of a reactivity imposing entity in the \textrm{Web}, other systems will start to deliver events into that entity, which requires detection of new events and information of users about them.

We believe that the \textrm{\gls{webofthings}} is a very promising field for such a reactivity imposing entity, but we were not able to study it in depth due to the lacking accessability of such things.
By reducing the interaction in term of event detection and action imposition to \textrm{\acrshort{rest}ful}, such as it is used for the \textrm{\gls{webofthings}}, it might be possible to incorporate the create, read, update and delete interactions with \textrm{\glspl{webservice}} into the rule language.
This would allow for an abstraction away from the \textrm{Event Trigger} and \textrm{Action Dispatcher} modules.
It would add stability and a generalization in a way that rules would become more complex to be implemented, but no more expert users are required to implement the code modules.
By using the read operation of the \textrm{\acrshort{rest}ful} \textrm{\acrshort{http}} for webpages, it could be possible to define the detection of changes on them.
Since it can be complex to derive an event and express an action with just one call to a service, it might be necessary to allow Web query chaining.
Such Web queries could then also be used in the condition section of a rule.

We have seen that the \textrm{\acrshort{eca}} paradigm is very well suitable to impose reactivity to \textrm{\glspl{infosystem}} and even in an intuitive way for the user to create rules.
The more challenging thing was to identify meaningful events that can be added to a rule by the user.
We have seen that it is common for existing \textrm{\acrshort{eca}} approaches to impose actions on local data rather than on remote \textrm{\glspl{infosystem}} over their services.
We defined a conceptual model that does not need any \textrm{\glspl{infosystem}} to understand events but orchestrates it flexibly over its existing services.

